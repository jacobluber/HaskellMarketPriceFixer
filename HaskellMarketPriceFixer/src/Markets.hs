module Markets where

import Helper
import TestCode
import DataTypes

{-
The current iteration of the program does not support user input from the command line.
Thus, currentbuyerinput refers to buyers and currentsellerinput refers to sellers.
Any number of buyers, sellers, and goods can be used.
A sample input of sellers and buyers is provided in the DataType module.
The value pricemultiplier refers to what every default price will be multiplied by to 
generate the maximum of the range of attempted prices for each good. 
Stylized output can be generated by loading the program in GHCi and calling "main". 
-}

-----------------------------MARKET MAIN FUNCTION-----------------------------

pricemultiplier = 2

sellerUtils :: [Offer] -> [Utility]
sellerUtils sellers = map (\(OfferInfo _ good) -> (frTup good)) sellers

getNewGood :: (Num t1, Num t2) => (String, t1, t2, t2) -> (String, t1, t2, t2)
getNewGood input = (\(goodN,units,mUtil,dec) -> (goodN,units+1,mUtil-dec,dec)) input

getActiveSeller :: [Offer] -> Offer
getActiveSeller sellers = head [ offer | offer@(OfferInfo sellerId (_,_,_,upd)) <- sellers, 
        upd == (maximum (sellerUtils sellers))]

getTempInactiveSellers :: [Offer] -> [Offer]
getTempInactiveSellers sellers = [ offer | offer@(OfferInfo sellerId (_,_,_,upd)) <- sellers, 
        upd /= (maximum (sellerUtils sellers))]

getBuyerGood :: MarketParticipant -> Offer -> OfferGood
getBuyerGood buyer seller = head [ ret | ret@(goodID,_,_,_) <- (buyerGoods buyer), 
        goodID == (fTup (goodInfo seller))]  

getBuyerGoods :: MarketParticipant -> Offer -> [OfferGood]
getBuyerGoods buyer seller = [ ret | ret@(goodID,_,_,_) <- (buyerGoods buyer), 
        goodID /= (fTup (goodInfo seller))]
        
matchMarketParticipants :: [Offer] -> [Offer] -> MarketParticipant -> (MarketParticipant,Offer,Offer,Money)
matchMarketParticipants sellersWithInventory dudSellers activeBuyer = 
 if sellersWithInventory == [] 
 then (activeBuyer, NoOffer, NoOffer, 0) 
 else let activeSeller = getActiveSeller sellersWithInventory
          tempInactiveSellers = getTempInactiveSellers sellersWithInventory
      in if ((moneyHeld activeBuyer) > (tTup (goodInfo activeSeller)))
        && ((maximum (sellerUtils sellersWithInventory)) > 0) 
         then let buyerGood = getBuyerGood activeBuyer activeSeller               
                  buyerGoods = getBuyerGoods activeBuyer activeSeller
                  newGoods = [getNewGood buyerGood] ++ buyerGoods                                             
                  updateBuyer = Buyer (buyerId activeBuyer) newGoods 
                        ((moneyHeld activeBuyer)-(tTup (goodInfo activeSeller))) 
                        ((accUtil activeBuyer)+(tTup buyerGood))                                                                                                                                                                                                                                                                                                          
                  updateActiveSeller = OfferInfo 
                        (sellerInfo activeSeller ) 
                        ((fTup (goodInfo activeSeller)), 
                        ((sTup (goodInfo activeSeller))-1), 
                        (tTup (goodInfo activeSeller)), 
                        (frTup (goodInfo activeSeller)))                                                                                                                        
              in (updateBuyer, updateActiveSeller, activeSeller, (tTup (goodInfo activeSeller)))                                                                                                                   
         else matchMarketParticipants tempInactiveSellers ([activeSeller] ++ dudSellers) activeBuyer             
         
getEndMarket :: [MarketParticipant] -> Market -> EndMarket
getEndMarket sellers result = 
 let unpackedResult = (\(Participants x) -> x) result
     accBuyerUtils = map (\(Buyer _ _ _ totalU) -> totalU) unpackedResult
     accBuyerUtil = foldl (+) 0 accBuyerUtils
     accSellerProfit = map (\(Seller _ _ cash) -> cash) sellers
     accSellerTotalProfit = foldl (+) 0 accSellerProfit                 
  in EndParticipants accSellerTotalProfit accBuyerUtil (unpackedResult++sellers)                

getUtilVals :: [(t, t1, b, t3)] -> [b]
getUtilVals = map tTup 

getSellerVals :: [MarketParticipant] -> [[(String, Stock)]]
getSellerVals = map (\(Seller sellerId goodInfo _) -> map (\goodInfo -> (sellerId,goodInfo)) goodInfo)

getOfferInput :: [a] -> [[b]] -> [(a, b)]
getOfferInput utils sellers = concat (map (\t -> zip utils t) sellers)

getOffers :: [(Utility, (Name, Stock))] -> [Offer]
getOffers input = map (\(utility, (sellerId, (goodId, units, priceCharged))) -> 
        OfferInfo sellerId (goodId, units, priceCharged,utility/priceCharged)) input

getValidOffers :: [Offer] -> [Offer]
getValidOffers offers = [ offerInfo | offerInfo@(OfferInfo sellerId (_,units,_,_)) <- offers, 
        units > 0 ]                                                                                                                                                                             
        
getInvalidOffers :: [Offer] -> [Offer]
getInvalidOffers offers = [ offerInfo | offerInfo@(OfferInfo sellerId (_,units,_,_)) <- offers, 
        units == 0]

getUnpackedInitialResult :: Market -> [MarketParticipant]
getUnpackedInitialResult = (\(Participants participant) -> participant)

getNewSellerIdent :: (t, t1, Offer, t3) -> Name     
getNewSellerIdent transaction = (\(OfferInfo sellerId (_,_,_,_)) -> sellerId) (tTup(transaction))

getRelevantSeller :: [MarketParticipant] -> String -> MarketParticipant
getRelevantSeller sellers newseller = head [ seller | seller@(Seller sellerId _ _) <- sellers, 
        sellerId == newseller] 

getIrrelevantSellers :: [MarketParticipant] -> Name -> [MarketParticipant]
getIrrelevantSellers sellers newseller = [ seller | seller@(Seller sellerId _ _) <- sellers, 
        sellerId /= newseller] 

getRelevantSellerGoods :: MarketParticipant -> [Stock]
getRelevantSellerGoods = (\(Seller sellerId goodInfo moneyHeld) -> goodInfo)

getgoodIdent :: Offer -> Stock
getgoodIdent = (\(OfferInfo sellerId (goodId,unitsGood,price,_)) -> (goodId,unitsGood,price))

getIrrelevantRelevantSellerGoods :: Eq t => [t] -> t -> [t]
getIrrelevantRelevantSellerGoods relevantGood goodIdent = [good|good<-relevantGood,good /= goodIdent]

getNewGoods :: (t, Offer, t2, t3) -> [Stock] -> [Stock]
getNewGoods transaction irrelevantRelevantSellerGoods =
  let newGood = (\(OfferInfo sellerId (goodId,units,priceCharged,_))
        -> (goodId,units,priceCharged)) (sTup(transaction))
  in [newGood] ++ irrelevantRelevantSellerGoods 
        
getNewSellers :: MarketParticipant -> [Char] -> (t1, Offer, t2, Float) ->
        [Stock] -> t -> [MarketParticipant] -> [MarketParticipant] 
getNewSellers relevantSeller newSellerIdent transaction irrelevantRelevantSellerGoods 
        oldSellerMoney irrelevantSellers = 
 let oldSellerMoney = (\(Seller _ _ moneyHeld) -> moneyHeld) relevantSeller 
     newSeller = (Seller newSellerIdent (getNewGoods transaction irrelevantRelevantSellerGoods) 
        (oldSellerMoney+(frTup(transaction)))) 
 in irrelevantSellers ++ [newSeller]
 
sellerIds :: [Name]
sellerIds = map sellerId currentsellerinput

getGoods :: Num t => MarketParticipant -> [(Good, Unit, t)]
getGoods seller = map (\(goodId,units,pricePaidForGood) -> (goodId,units,-1)) (sellerGoods seller)  

sellervals :: Num t => [MarketParticipant] -> [[(Good, Unit, t)]]
sellervals sellers = map getGoods sellers

--makeTransaction        
offersForBuyer :: [(t, t1, Float, t3)] -> [MarketParticipant] -> [MarketParticipant] -> 
        (MarketParticipant, Offer, Offer, Float)
offersForBuyer utilValsInput sellers buyers = 
 let utilVals = getUtilVals utilValsInput
     sellerVals = getSellerVals sellers
     offerInput = getOfferInput utilVals sellerVals
     offers = getOffers offerInput
     validOffers = getValidOffers offers
     invalidOffers = getInvalidOffers offers
 in matchMarketParticipants validOffers [] (head(buyers))

processBuyers :: (MarketParticipant, Offer, Offer, Float) -> [MarketParticipant] ->
        [MarketParticipant] -> Market -> EndMarket
processBuyers transaction sellers buyers result = 
 let newSellerIdent =  getNewSellerIdent transaction
     relevantSeller = getRelevantSeller sellers newSellerIdent 
     irrelevantSellers = getIrrelevantSellers sellers newSellerIdent
     relevantSellerGoods = getRelevantSellerGoods relevantSeller
     goodIdent = getgoodIdent (tTup(transaction))
     irrelevantRelevantSellerGoods = getIrrelevantRelevantSellerGoods relevantSellerGoods goodIdent
     oldSellerMoney = (\(Seller sellerId goodInfo moneyHeld) -> moneyHeld) relevantSeller 
 in priceFix ((fTup(transaction)):(tail(buyers))) 
        (getNewSellers relevantSeller newSellerIdent transaction 
        irrelevantRelevantSellerGoods oldSellerMoney irrelevantSellers) result
 
priceFix:: [MarketParticipant] -> [MarketParticipant] -> Market -> EndMarket
priceFix buyers sellers result = 
 if buyers == [] 
 then getEndMarket sellers result
 else let transaction = offersForBuyer (buyerGoods (head(buyers))) sellers buyers
      in if (((fTup(transaction)) == (head(buyers))) && (result == Empty)) 
         then priceFix (tail(buyers)) sellers (Participants ([(head(buyers))]))
         else if (fTup(transaction)) == (head(buyers))
              then priceFix (tail(buyers)) sellers  (Participants ([(head(buyers))]++
                (getUnpackedInitialResult result)))
              else processBuyers transaction sellers buyers result

getSellerInput :: MarketParticipant -> [[Float]]
getSellerInput input = 
 let goods = (\(Seller _ goodInfo _) -> goodInfo) input
     purchasePrices = map (\(goodId,_,pricePaid) -> pricePaid) goods
     range = (map (\price -> [price..(price*pricemultiplier)]) purchasePrices)
     result = sequence range
 in result        

getSellerInputs :: [MarketParticipant] -> [[[Float]]]
getSellerInputs input =  map getSellerInput input 

getFinalInputs :: [MarketParticipant] -> [[[Float]]]
getFinalInputs sellerinput = 
 let input = getSellerInputs sellerinput
     result = sequence input 
 in result

input :: [[([Float], [(Good, Unit, Integer)])]]
input = map (\finalinputs -> zip finalinputs (sellervals currentsellerinput)) (getFinalInputs currentsellerinput)

createSellerGoods :: ([Float], [(Good, Unit, Integer)]) -> [(String,Int,Float)]
createSellerGoods ([], _) = []
createSellerGoods (_,[]) = []
createSellerGoods (newprice:newprices, oldgood:oldgoods) = 
        [(fTup' oldgood,sTup' oldgood,newprice)] ++ createSellerGoods (newprices, oldgoods)

createSellersGoods :: [[([Float], [(Good, Unit, Integer)])]] -> [[[(String, Int, Float)]]]
createSellersGoods input = map (map createSellerGoods) input 

almostSellers :: [[([Float], [(Good, Unit, Integer)])]] -> [[(String, [(String, Int, Float)])]]
almostSellers sellersgoodsinput = map (zip sellerIds) (createSellersGoods sellersgoodsinput) 

createSeller :: (String, [(Good, Unit, Float)]) -> MarketParticipant
createSeller (sellerId,goodInfo) = Seller sellerId goodInfo 0

createSellers :: [[([Float], [(Good, Unit, Integer)])]] -> [[MarketParticipant]]
createSellers seller = map (map createSeller) (almostSellers seller) 

marketOutcomes :: [EndMarket]
marketOutcomes = map (\seller -> priceFix currentbuyerinput seller Empty) (createSellers input)

mostProfit :: Money
mostProfit = maximum (map (\(EndParticipants profit _ _) -> profit) marketOutcomes)

mostUtility :: Utility
mostUtility = maximum (map (\(EndParticipants _ totalBuyerUtil _) -> totalBuyerUtil) marketOutcomes)

marketProfits :: [EndMarket]
marketProfits = [ endP | endP@(EndParticipants totalSellerProfit _ _) <- marketOutcomes, totalSellerProfit==mostProfit]

marketUtility :: [EndMarket]
marketUtility = [ endP | endP@(EndParticipants _ totalBuyerUtil _)<-marketOutcomes, totalBuyerUtil==mostUtility]                              

-----------------------------I/O-----------------------------

main :: IO() 
main = do
putStrLn ("For the market of buyers and sellers represented by: ")
putStrLn ("Buyers: "++show testbuyers)
putStrLn ("Sellers: "++show testsellers)
putStrLn (" ")
putStrLn ("The algorithm has tested "++show (length marketOutcomes)++" different market outcomes.")
putStrLn ("Of these outcomes, the one(s) that get(s) the most seller profit("++(show mostProfit)++") is/are: ")
putStrLn (show marketProfits)
putStrLn (" ")
putStrLn ("Of these outcomes, the one(s) that get(s) the most buyer utility("++(show mostUtility)++") is/are: ")
putStrLn (show marketUtility)